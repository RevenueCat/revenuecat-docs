# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

# Uncomment the line if you want fastlane to automatically update itself
require 'json'
require 'fileutils'
require 'uri'
require 'net/http'
require 'pathname'
require 'yaml'

CATEGORIES_FILE = "docs_source/categories.json"
CATEGORIES_TEST_FILE = "docs_source/categories_test_project.json"
CATEGORIES_MAP_FILE = "docs_source/categories_map.json"
VERSION_FILE = "docs_source/.version"
SOURCE_FOLDER = "docs_source"
RENDER_FOLDER = "rendered_docs"
REPO_NAME = "revenuecat-docs"

update_fastlane

default_platform(:ios)

desc "Install dependencies"
lane :bootstrap do
    sh "npm", "install", "-g", "rdme@8.6.4-next.2"
end

lane :ios_tests do
    Dir.chdir(File.join(root_dir, "projects", "iOS")) do
        sh "xcodebuild -scheme ApplePlatforms-Package -destination 'generic/platform=iOS'"
    end
end

lane :copy_docs_source_to_render_folder do
    Dir.chdir(root_dir) do
        FileUtils.rm_rf RENDER_FOLDER
        FileUtils.copy_entry SOURCE_FOLDER, RENDER_FOLDER
    end
end

lane :sync_files_to_readme do |options|
    current_version = get_current_version
    Dir.chdir(root_dir) do
        sh "rdme docs rendered_docs --version\=#{current_version} --key\=#{options[:readme_api_key]}"
    end
    UI.message("ðŸ”¨ Syncing files to Readme...")
end

desc <<-DESC
Extracts code blocks from within the [block:code] and [/block] tags and saves each code block to a file
folder, STRING Folder to recurse through and extract code blocks from all markdown files. Path is relative to the root of the project.
DESC
lane :extract_code_blocks do |options|
    markdown_files.each do |file_name|
        UI.message("ðŸ”¨ Processing #{file_name}...")
        current_folder = File.dirname(file_name)
        UI.message("ðŸ”¨ Current folder #{current_folder}...")
        folder_inside_docs_source = current_folder.sub(/^#{SOURCE_FOLDER}\//, "")
        output_dir = "code_blocks/#{folder_inside_docs_source}"

        file_contents = get_file_contents(file_name)

        Dir.chdir(root_dir) do
            FileUtils.mkdir_p(output_dir)
        end

        file_contents = convert_old_style_code_blocks(file_contents)

        code_blocks = file_contents.scan(/```\w+[\s\S]+?```/)
        total_blocks = code_blocks.length

        code_blocks.each_with_index.map do |block, index|
            filename_without_ext = File.basename(file_name, ".md")
            UI.message("ðŸ”¨ Processing code block #{index + 1}/#{total_blocks} in #{file_name}...")
            code_block_information = extract_block_to_file(output_dir, filename_without_ext, block, index)
            if code_block_information.length > 0
                file_contents.gsub!("#{block}", "[block:file]\n#{code_block_information.to_json}\n[/block]")
            end
        end

        write_file_contents(file_name, file_contents)
    end
end

desc <<-DESC
Embeds code blocks from all files and opens a pull request preparing the docs for syncing to Readme
DESC
lane :open_syncing_pr do |options|
    github_pr_token = options[:github_pr_token]

    latest_commit_sha = get_latest_commit_sha

    current_version = get_current_version

    new_branch_name = "sync/#{current_version}"

    validate_local_config_status_for_bump(new_branch_name, github_pr_token)

    create_new_branch_and_checkout(new_branch_name)
    embed_code_blocks
    update_docs_structure(options)

    pr_title = "Syncing #{latest_commit_sha} with #{current_version}"
    body = <<~EOS
        âš ï¸âš ï¸âš ï¸ MERGING THIS PR WILL SYNC THE REPOSITORY WITH README âš ï¸âš ï¸âš ï¸
        Syncing docs to release #{current_version} of the docs. This PR was automatically generated by the RevenueCat bot.
    EOS

    if git_repo_dirty?
        commit_changes_and_push_current_branch("Rendered docs for commit #{latest_commit_sha}")
        create_pr_to_main(pr_title, body, REPO_NAME, new_branch_name, github_pr_token, [])
    else
        UI.message("Repository is clean. Nothing to commit.")
    end
end

desc "Embeds code blocks from all files within the [block:file] and [/block] tags"
lane :embed_code_blocks do |options|
    copy_docs_source_to_render_folder

    Dir.chdir(root_dir) do
        Dir.glob("#{RENDER_FOLDER}/**/*.md").each do |file_name|
            file_contents = File.read(file_name)

            file_contents.scan(/\[block:file\].*?\[\/block\]/m).each_with_index.map do |block, index|
                UI.message("ðŸ”¨ Processing file block #{index} in #{file_name}...")
                code_to_embed = embed_code_from_files(block)
                file_contents.gsub!("#{block}", "#{code_to_embed.chomp}")
            end

            File.write(file_name, file_contents)
        end
    end
end

desc <<-DESC
Updates rendered docs folder to the current category, order and parent information from Readme
readme_api_key, STRING Readme API key for the project
DESC
lane :update_docs_structure do |options|
    readme_api_key = options[:readme_api_key]
    UI.user_error!("Missing README API key") unless readme_api_key

    folder_path = RENDER_FOLDER

    markdown_files(folder_path).each do |file|
        UI.message("Updating #{file}")

        yaml_data = get_doc_information_from_header(file)
        slug = yaml_data["slug"]
        doc_information_from_server = get_doc_information(slug, readme_api_key)

        UI.message("Doc information retrieved from server")
        doc_order = doc_information_from_server["order"]
        doc_parent_doc = doc_information_from_server["parentDoc"]
        doc_category = doc_information_from_server["category"]

        update_doc_information(file, doc_category, doc_order, doc_parent_doc)
    end
end

desc <<-DESC
Removes all categories from docs_source
DESC
lane :remove_categories_from_docs_source do |options|
    folder_path = SOURCE_FOLDER

    markdown_source_files.each do |filename|
        next if filename == '.' || filename == '..'
        file_without_folder_path = filename.gsub("#{folder_path}/", "")
        UI.message("Updating #{file_without_folder_path}")

        Dir.chdir(root_dir) do
            file = File.read(filename)
            yaml_header, content = file.split('---', 3)[1..-1]
            yaml_data = YAML.load(yaml_header)

            yaml_data.delete('category')

            File.write(filename, "#{yaml_data.to_yaml}---#{content}")
        end
    end
end

# This is destructive and will delete all categories in the project
# So in order to prevent misusage, it is commented out for now, just in case we need to clear the test
# project. Will be removed when we are sure we don't need it anymore (when we switch to production)
# lane :delete_test_categories do |options|
#     readme_api_key_test = options[:readme_api_key_test]
#     UI.user_error!("Missing README API key for test project") unless readme_api_key_test
#
#     get_json_from_file(CATEGORIES_TEST_FILE).each do |category|
#         sleep(1)
#         UI.message("Deleting category #{category['title']}")
#         uri = URI("https://dash.readme.com/api/v1/categories/#{category['slug']}")
#         request = Net::HTTP::Delete.new(uri)
#         request.content_type = 'application/json'
#         request.basic_auth(readme_api_key_test, '')
#
#         request['accept'] = 'application/json'
#         request['x-readme-version'] = get_current_version
#
#         res = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) do |http|
#             http.request(request)
#         end
#         p res.code
#     end
#     update_categories_file(CATEGORIES_TEST_FILE, readme_api_key_test)
# end

desc <<-DESC
Updates the JSON files containing the categories for a Readme.com project.
readme_api_key, STRING Readme API key for the project
readme_api_key_test STRING Readme API key for the test project
DESC
lane :update_categories_file do |options|
    readme_api_key = options[:readme_api_key]
    UI.user_error!("Missing README API key") unless readme_api_key

    readme_api_key_test = options[:readme_api_key_test]
    UI.user_error!("Missing README API key for test project") unless readme_api_key_test

    update_categories_file(CATEGORIES_FILE, readme_api_key)
    update_categories_file(CATEGORIES_TEST_FILE, readme_api_key_test)
end

desc <<-DESC
Updates the JSON files containing the categories for a Readme.com project, including categories.json,
categories_test_project.json and categories_map.json and creates matching categories in the readme test project.
readme_api_key, STRING Readme API key for the project
readme_api_key_test STRING Readme API key for the test project
DESC
lane :sync_categories_between_projects do |options|
    readme_api_key = options[:readme_api_key]
    UI.user_error!("Missing README API key") unless readme_api_key

    readme_api_key_test = options[:readme_api_key_test]
    UI.user_error!("Missing README API key for test project") unless readme_api_key_test

    production_to_test_category_ids = {}
    categories_from_production = update_categories_file(CATEGORIES_FILE, readme_api_key)
    categories_from_production = categories_from_production.sort_by { |category| category['order'] }
    categories_from_production.each do |category|
        response = post_category(category['type'], category['title'], readme_api_key_test)

        production_to_test_category_ids[category['id']] = JSON.parse(response.body)['id']
    end

    Dir.chdir(root_dir) do
        File.open(CATEGORIES_MAP_FILE, 'w+') do |file|
            file.write(JSON.pretty_generate(production_to_test_category_ids))
        end
    end
    update_categories_file(CATEGORIES_TEST_FILE, readme_api_key_test)
end

desc <<-DESC
Updates categories for all the docs in a folder. It tries to guess the category using the folder that contains the
document and uses Readme's API as a backup
readme_api_key, STRING Readme API key for the project
force_update_categories BOOLEAN True will force the categories.json to be updated, false will use the existing categories.json
DESC
lane :update_docs_categories do |options|
    readme_api_key = options[:readme_api_key]
    UI.user_error!("Missing README API key") unless readme_api_key

    force_update_categories = options[:force_update_categories]
    if force_update_categories
        update_categories_file(CATEGORIES_FILE, readme_api_key)
    end

    categories = get_json_from_file(CATEGORIES_TEST_FILE)

    markdown_files.each do |file|
        file_without_folder_path = file.gsub("#{SOURCE_FOLDER}/", "")
        category_name = file_without_folder_path.split("/")[0]
        UI.message("file_without_folder_path #{file_without_folder_path} Category name: #{category_name}")
        category = categories.find { |category|
            category['title'] == category_name
        }
        if category != nil
            p "Category #{category_name} found for file #{file}"
            category_for_doc = category['id']
        else
            p "Category #{category_name} not found for file #{file}"
            slug = File.basename(file, ".md")
            category_for_doc_prod = get_category_id_for_doc(slug, readme_api_key)
            p "Category retrieved from server: #{category_for_doc_prod}"
            categories_map_from_file = get_json_from_file(CATEGORIES_MAP_FILE)
            category_for_doc = categories_map_from_file[category_for_doc_prod]
        end

        update_category_cleanup_dates(file, category_for_doc)
    end
end

desc <<-DESC
Updates categories for all the docs in a folder. It tries to guess the category using the folder that contains the
document and uses Readme's API as a backup
readme_api_key, STRING Readme API key for the project
force_update_categories BOOLEAN True will force the categories.json to be updated, false will use the existing categories.json
DESC
lane :sync_order_with_test_project do |options|
    readme_api_key = options[:readme_api_key]
    UI.user_error!("Missing README API key") unless readme_api_key

    readme_api_key_test = options[:readme_api_key_test]
    UI.user_error!("Missing README API key for test project") unless readme_api_key_test

    categories_prod = get_json_from_file(CATEGORIES_FILE)
    categories_prod.each do |category|
        category_id_test = get_json_from_file(CATEGORIES_MAP_FILE)[category['id']]
        UI.message("Updating order for category #{category_id_test}")
        category_test = get_json_from_file(CATEGORIES_TEST_FILE).find { |category|
            category['id'] == category_id_test
        }

        prod_cat_slug = category['slug']
        UI.message("â¬‡ï¸ Getting docs for category #{prod_cat_slug}")
        docs_for_category = get_docs_for_category(prod_cat_slug, readme_api_key)
        test_cat_slug = category_test['slug']
        UI.message("â¬‡ï¸ Getting docs for test category #{test_cat_slug}")
        docs_for_category_test = get_docs_for_category(test_cat_slug, readme_api_key_test)

        docs_for_category.each do |doc_prod|
            doc_prod_title = doc_prod['title']
            UI.message("Updating doc order for #{doc_prod_title}")
            doc_test = docs_for_category_test.find { |doc_test| doc_test['title'] == doc_prod_title }
            if doc_test == nil
                UI.error("Doc #{doc_prod_title} not found in test project. Skipping... It could be an API reference doc.")
                UI.error("Production docs for category #{docs_for_category}")
                UI.error("Test docs for category #{docs_for_category_test}")
                next
            end
            doc_order = doc_prod['order']
            doc_children = doc_prod['children']

            doc_slug_prod = doc_prod['slug']
            doc_slug_test = doc_test['slug']

            UI.message("Updating #{doc_prod_title}; prod_slug #{doc_slug_prod}; test_slug #{doc_slug_test}; order #{doc_order}")

            update = update_doc(doc_slug_test, doc_order, nil, readme_api_key_test)
            UI.message("Doc order updated to #{update['order']}")

            if doc_children
                doc_children.each do |child_doc|
                    child_doc_title = child_doc['title']
                    child_doc_order = child_doc['order']
                    child_doc_slug = child_doc['slug']

                    UI.message("Updating child doc #{child_doc_title}; #{child_doc_slug}; order #{child_doc_order}")
                    update = update_doc(child_doc_slug, child_doc_order, doc_slug_test, readme_api_key_test)
                    UI.message("Doc order updated to #{update['order']} and parentDoc to #{update['parentDoc']}")
                end
            end
        end
    end
end

##
# Embeds all files within the [block:file] and [/block] tags and adds the content of the file as a code block
#
# For example this block in a markdown file named docs_source/v4.0.1/-- Resources/server-notifications/example.md:
#
# [block:file]
# javascript->code_blocks/docs_source/v4.0.1/-- Resources/server-notifications/example_1.js
# [/block]
#
# Will be converted to:
# [block:code]
# {
#   "codes": [
#     {
#       "code": "var a = 1;",
#       "language": "javascript"
#     }
#   ]
# }
# [/block]
#
# @param file_block [String] the input string containing the code block. This is the entire string that contains the
# file block including the [block:file] and [/block] tags
# @return [String] a string containing the code blocks from all the files within the file block
def embed_code_from_files(file_block)
    block = extract_code_block(file_block)
    new_content = []

    block.each_line do |line|
        next if line.start_with?("[")
        file_tag_content = line.strip
        json = JSON.parse(file_tag_content)
        UI.message("Extracted json: #{block}")

        language = json['language']
        file_path = json['file']
        name = json['name']
        next unless File.exist?(file_path)

        file_content = File.read(file_path)
        new_content.push "```#{language} #{name}\n#{file_content}\n```"
    end

    new_content.join("\n").strip
end

##
# Extracts all code blocks from within the [block:code] and [/block] tags and saves each code block to a file, with the
# correct extension.
#
# For example this code block in a markdown file named docs_source/v4.0.1/-- Resources/server-notifications/example.md:
#
# [block:code]
# {
#   "codes": [
#     {
#       "code": "var a = 1;",
#       "language": "javascript"
#     }
#   ]
# }
# [/block]
#
# Will be converted to:
# [block:file]
# javascript->code_blocks/docs_source/v4.0.1/-- Resources/server-notifications/example_1.js
# [/block]
#
# And the code block will be saved to code_blocks/docs_source/v4.0.1/-- Resources/server-notifications/example_1.js
# @param output_dir [String] the output directory to save the file
# @param file_name_no_ext [String] the name of the file where this code block lives, without extension
# @param code_block [String] the input string containing the code block. This is the entire string that contains the
# code block including the [block:code] and [/block] tags
# @param index [Integer] the index of the code block within the file. This is used to create a unique file name for each
# code block
# @return [Hash] a hash of language to file paths for the extracted code blocks
def extract_block_to_file(output_dir, file_name_no_ext, code_block, index)
    code_information = extract_markdown_code_block_information(code_block)
    if code_information
        language = code_information["language"]
        code = code_information["code"].strip
        extension = determine_extension(language)
        new_file = "#{output_dir}/#{file_name_no_ext}_#{index + 1}.#{extension}"
        Dir.chdir(root_dir) do
            File.write(new_file, code)
        end
        UI.message("âš™ï¸  Creating #{new_file}...")

        {
            "language" => language,
            "name" => code_information["name"],
            "file" => new_file,
        }
    else
        {}
    end
end

def extract_markdown_code_block_information(code_block)
    lines = code_block.split("\n")
    if lines.length > 1 # code blocks in callouts are one liners. Don't process them
        header = lines[0].sub("```", "").split(" ")
        language = header[0]
        name = header.length > 1 ? header[1..-1].join(" ") : "" # Name is everything after the language and it's optional
        code = lines[1..-2].join("\n") # Code is everything between the first and last line
        {
            "language" => language,
            "name" => name,
            "code" => code,
        }
    else
        nil
    end
end

def extract_code_block(code_block)
    block_start = code_block.index("[block:")
    block_end = code_block.index("[/block]", block_start)
    code_block[block_start..block_end].strip
end

##
# A map of languages to their corresponding file extensions
LANGUAGE_EXTENSIONS = {
    "objectivec" => "m",
    "kotlin" => "kt",
    "javascript" => "js",
    "typescript" => "ts",
    "csharp" => "cs",
    "text" => "txt"
}

##
# Determines the file extension for a given language
# @param lang [String] the language
# @return [String] the file extension
def determine_extension(lang)
    LANGUAGE_EXTENSIONS[lang.downcase] || lang
end

##
# Determines the language for a given file extension
# @param extension [String] the file extension
# @return [String] the language
def determine_language(extension)
    LANGUAGE_EXTENSIONS.key(extension) || extension
end

# Updates the order and parentDocSlug for a given doc.
#
# @param [String] doc_slug The slug of the doc to update
# @param [String] doc_order The order of the doc
# @param [String] parent_doc The parent doc's slug
# @param [String] readme_api_key The ReadMe API key
def update_doc(doc_slug, doc_order, parent_doc, readme_api_key)
    url = URI("https://dash.readme.com/api/v1/docs/#{doc_slug}")
    request = Net::HTTP::Put.new(url)
    request.content_type = "application/json"
    request.basic_auth(readme_api_key, '')
    request["x-readme-version"] = get_current_version
    request.body = JSON.dump({
                                 "order" => doc_order,
                                 "parentDocSlug" => parent_doc
                             })

    response = Net::HTTP.start(url.hostname, url.port, use_ssl: url.scheme == "https") do |http|
        http.request(request)
    end

    JSON.parse(response.read_body)
end

# Retrieve all the docs for a given category using the ReadMe API.
#
# @param [String] category_slug Slug of the category for which to retrieve the docs.
# @param [String] readme_api_key API key for the ReadMe account that has access to the categories.
#
# @return [JSON] Docs for the given category.
def get_docs_for_category(category_slug, readme_api_key)
    url = URI(URI::Parser.new.escape(("https://dash.readme.com/api/v1/categories/#{category_slug}/docs")))
    https = Net::HTTP.new(url.host, url.port)
    https.use_ssl = true

    request = Net::HTTP::Get.new(url)
    request.basic_auth(readme_api_key, '')

    request["x-readme-version"] = get_current_version

    response = https.request(request)
    JSON.parse(response.read_body)
end

# Updates the category for a given document.
# It will also update the createdAt field if it's empty.
# This is needed because the createdAt field is sometimes not exported from ReadMe.
#
# @param [String] filename Name of the file to update
# @param [String] category_id ID of the category to update the document with
def update_category_cleanup_dates(filename, category_id)
    Dir.chdir(root_dir) do
        file = File.read(filename)
        yaml_header, content = file.split('---', 3)[1..-1]
        yaml_data = YAML.load(yaml_header)

        yaml_data['category'] = category_id

        created_at = yaml_data['createdAt']
        updated_at = yaml_data['updatedAt']
        if created_at == {}
            UI.message("Updating createdAt for #{filename} to #{updated_at}")
            yaml_data['createdAt'] = updated_at
        end

        File.write(filename, "#{yaml_data.to_yaml}---#{content}")
    end
end

# Updates the category, order and parent for a given document.
# It will also update the updatedAt field if needed.
#
# @param [String] filename Name of the file to update
# @param [String] category_id ID of the category to update the document with
# @param [String] order Order of the doc in the category
# @param [String] parent_doc_id Parent ID of the doc
def update_doc_information(filename, category_id, order, parent_doc_id)
    Dir.chdir(root_dir) do
        file = File.read(filename)
        yaml_header, content = file.split('---', 3)[1..-1]
        yaml_data = YAML.load(yaml_header)
        updated = false

        original_category = yaml_data['category']
        if original_category != category_id
            UI.message("Updating category of #{filename} from #{original_category} to #{category_id}")
            yaml_data['category'] = category_id
            updated = true
        end

        original_order = yaml_data['order']
        if original_order != order
            UI.message("Updating order of #{filename} from #{original_order} to #{order}")
            yaml_data['order'] = order
            updated = true
        end

        original_parent = yaml_data['parentDoc']
        if parent_doc_id && original_parent != parent_doc_id
            UI.message("Updating parent of #{filename} from #{original_parent} to #{parent_doc_id}")
            yaml_data['parentDoc'] = parent_doc_id
            updated = true
        end

        if updated
            current_date = Time.now.utc.strftime('%Y-%m-%dT%H:%M:%S.%LZ')
            yaml_data['updatedAt'] = current_date
        end

        File.write(filename, "#{yaml_data.to_yaml}---#{content}")
    end
end

def get_doc_information_from_header(filename)
    Dir.chdir(root_dir) do
        file = File.read(filename)
        yaml_header, _ = file.split('---', 3)[1..-1]
        YAML.load(yaml_header)
    end
end

# Replace emoji with -- to match how folders are exported from readme.
# Also replaces & with - to match how folders are exported from readme.
# This is needed because the folder names have emojis or & in their titles and Readme
# doesn't add the emojis to the folder name.
#
# @param [String] text Text to clean
def clean_category_title(text)
    text.gsub(/\p{Emoji}/, "--").gsub(/&/, "-")
end

# Get the JSON from a file.
#
# @param [String] file Path to the file to read.
def get_json_from_file(file)
    Dir.chdir(root_dir) do
        file = File.read(file)
        JSON.parse(file)
    end
end

def get_current_version
    Dir.chdir(root_dir) do
        File.read(VERSION_FILE).strip
    end
end

# Retrieve a list of categories from the ReadMe API and save it to a file.
#
# @param [String] categories_file Path to the file where the categories will be saved.
# @param [String] readme_api_key API key for the ReadMe account that has access to the categories.
#
# @return [JSON] Categories retrieved from the ReadMe API.
def update_categories_file(categories_file, readme_api_key)
    url = URI("https://dash.readme.com/api/v1/categories?perPage=100&page=1")

    https = Net::HTTP.new(url.host, url.port)
    https.use_ssl = true

    request = Net::HTTP::Get.new(url)
    request.basic_auth(readme_api_key, '')

    request["x-readme-version"] = get_current_version

    response = https.request(request)

    if response.code != '200'
        UI.user_error!("Error retrieving categories from ReadMe.\nResponse code: #{response.code} \nResponse body: #{response.body}")
    end

    json_data = JSON.parse(response.read_body).sort_by { |category| category['order'] }
    Dir.chdir(root_dir) do
        File.open(categories_file, 'w+') do |file|
            file.write(JSON.pretty_generate(json_data))
        end
    end
    json_data
end

# Retrieve the category ID for a given document slug from the ReadMe API.
#
# @param [String] slug The slug of the document to retrieve the category ID for.
# @param [String] readme_api_key API key for the ReadMe account that has access to the document.
#
# @return [String] ID of the category the document belongs to.
def get_category_id_for_doc(slug, readme_api_key)
    doc_information = get_doc_information(slug, readme_api_key)
    doc_information["category"]
end

# Retrieve the doc information for a given document slug from the ReadMe API.
#
# @param [String] slug The slug of the document to retrieve the category ID for.
# @param [String] readme_api_key API key for the ReadMe account that has access to the document.
#
# @return [Hash] Ruby data structure with the doc's information.
def get_doc_information(slug, readme_api_key)
    url = URI("https://dash.readme.com/api/v1/docs/#{slug}")

    https = Net::HTTP.new(url.host, url.port)
    https.use_ssl = true

    request = Net::HTTP::Get.new(url)
    request.basic_auth(readme_api_key, '')

    request["x-readme-version"] = get_current_version

    response = https.request(request)
    JSON.parse(response.read_body)
end

# Create a new category in the ReadMe API.
#
# @param [String] type The type of category to create
# @param [String] title title of the new category
# @param [String] readme_api_key API key for the ReadMe account that has access to create the category
#
# @return [Net::HTTP] Response from the ReadMe API
def post_category(type, title, readme_api_key)
    uri = URI('https://dash.readme.com/api/v1/categories')
    request = Net::HTTP::Post.new(uri)
    request.content_type = 'application/json'
    request.basic_auth(readme_api_key, '')

    request['accept'] = 'application/json'
    request['x-readme-version'] = get_current_version
    request.body = JSON.dump({
                                 "type" => type,
                                 "title" => title,
                             })

    Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) do |http|
        http.request(request)
    end
end

def root_dir
    File.dirname(Dir.pwd)
end

# Searches for is [block:code][/block] and replaces it with the Readme flavored markdown style code blocks.
# For example:

# [block:code]
# {
#  "codes": [
#  {
#    "code": "This is a code block",
#    "language": "text",
#    "name": "Code block"
#  },
#  {
#    "code": "This is another code block",
#    "language": "text",
#    "name": "Another code block"
#  }]
# }
# [/block]
#
# becomes
#
# ```text Code block
# This is a code block
# ```
# ```text Another code block
# This is another code block
# ```
def convert_old_style_code_blocks(input)
    block_code_regex = /\[block:code\]\s*(\{[\s\S]*?\})\s*\[\/block\]/

    input.gsub(block_code_regex) do |code_block_tag|
        block = extract_code_block(code_block_tag)
        json = block[block.index("{")..block.rindex("}")]
        data = JSON.parse(json)
        codes = data["codes"]
        new_style_code_blocks = ""

        UI.message("ðŸ”¨ Will migrate #{codes.count} code blocks within a [block:code] tag to backticks...")

        codes.each do |code_item|
            new_style_code_blocks += process_code_block(code_item)
        end

        new_style_code_blocks
    end
end

def process_code_block(code_item)
    code = code_item["code"].strip
    language = code_item["language"].strip
    name = code_item.key?("name") ? code_item["name"].strip : nil

    if name
        new_style_code_block = "```#{language} #{name}\n#{code}\n```\n"
    else
        new_style_code_block = "```#{language}\n#{code}\n```\n"
    end

    new_style_code_block
end

def markdown_files(folder = SOURCE_FOLDER)
    Dir.chdir(root_dir) do
        Dir.glob("#{folder}/**/*.md")
    end
end

def git_repo_dirty?
    status = sh("git status --porcelain")
    !status.empty?
end

# Replace with fastlane plugin's
def validate_local_config_status_for_bump(new_branch, github_pr_token)
    # Ensure GitHub API token is set
    if github_pr_token.nil? || github_pr_token.empty?
        UI.error("A github_pr_token parameter or an environment variable GITHUB_PULL_REQUEST_API_TOKEN is required to create a pull request")
        UI.error("Please make a fastlane/.env file from the fastlane/.env.SAMPLE template")
        UI.user_error!("Could not find value for GITHUB_PULL_REQUEST_API_TOKEN")
    end
    ensure_new_branch_local_remote(new_branch)
    ensure_git_status_clean
end

# Replace with fastlane plugin's
def self.ensure_new_branch_local_remote(new_branch)
    local_branches = sh('git', 'branch', '--list', new_branch)
    unless local_branches.empty?
        UI.error("Branch '#{new_branch}' already exists in local repository.")
        UI.user_error!("Please make sure it doesn't have any unsaved changes and delete it to continue.")
    end

    remote_branches = sh('git', 'ls-remote', '--heads', 'origin', new_branch)
    if !remote_branches.nil? && remote_branches.include?(new_branch)
        UI.error("Branch '#{new_branch}' already exists in remote repository.")
        UI.user_error!("Please make sure it doesn't have any unsaved changes and delete it to continue.")
    end
end

def get_latest_commit_sha
    sh("git rev-parse --short HEAD").strip
end

# Replace with fastlane plugin's
def create_new_branch_and_checkout(branch_name)
    sh("git checkout -b '#{branch_name}'")
end

# Replace with fastlane plugin's
def commit_changes_and_push_current_branch(commit_message)
    commit_current_changes(commit_message)
    Actions::PushToGitRemoteAction.run(remote: 'origin')
end

def commit_current_changes(commit_message)
    sh('git add -A')
    sh("git commit -am '#{commit_message}'")
end

def create_pr_to_main(title, body, repo_name, head_branch, github_pr_token, labels = [])
    Actions::CreatePullRequestAction.run(
        api_token: github_pr_token,
        title: title,
        base: 'main',
        body: body,
        repo: "RevenueCat/#{repo_name}",
        head: head_branch,
        api_url: 'https://api.github.com',
        labels: labels,
        team_reviewers: ['support']
    )
end

def get_file_contents(file)
    Dir.chdir(root_dir) do
        File.read(file)
    end
end

def write_file_contents(file, file_contents)
    Dir.chdir(root_dir) do
        File.write(file, file_contents)
    end
end
