# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

# Uncomment the line if you want fastlane to automatically update itself
require 'json'
require 'fileutils'
require 'uri'
require 'net/http'
require 'pathname'
require 'yaml'
import 'readme_api/api.rb'
import 'readme_api/versions.rb'
import 'categories.rb'
import 'files.rb'
import 'circleci_api/api.rb'
import 'code_blocks/code_blocks.rb'
import 'rendering.rb'

VERSION_FILE = "docs_source/.version"
SOURCE_FOLDER = "docs_source"
CODE_BLOCKS_FOLDER = "code_blocks"
RENDER_FOLDER = "rendered_docs"
TEMPORARY_RENDER_FOLDER = "temp"
REPO_NAME = "revenuecat-docs"

update_fastlane

default_platform(:ios)


lane :sync_files_to_readme do |options|
    readme_api_key = ENV["RDME_API_KEY"]
    UI.user_error!("Missing README API key") unless readme_api_key

    current_version = get_current_version
    Dir.chdir(root_dir) do
        sh("rdme", "docs", "rendered_docs", "--version", "#{current_version}")
    end
    UI.message("🔨 Syncing files to Readme...")
end

desc <<-DESC
Extracts code blocks from within the [block:code] and [/block] tags and saves each code block to a file
folder, STRING Folder to recurse through and extract code blocks from all markdown files. Path is relative to the root of the project.
DESC
lane :extract_code_blocks do |options|
    markdown_files = markdown_files(SOURCE_FOLDER)
    extract_code_blocks(SOURCE_FOLDER, CODE_BLOCKS_FOLDER, markdown_files)
end

desc <<-DESC
Embeds code blocks from all files and opens a pull request preparing the docs for syncing to Readme
DESC
lane :open_syncing_pr do |options|
    readme_api_key = ENV["RDME_API_KEY"]
    UI.user_error!("Missing README API key") unless readme_api_key

    github_pr_token = ENV["GITHUB_API_TOKEN"]

    latest_commit_sha = get_latest_commit_sha

    current_version = get_current_version

    new_branch_name = "sync/#{current_version}"

    validate_local_config_status_for_bump(new_branch_name, github_pr_token)

    create_version_if_needed(current_version, readme_api_key)

    create_new_branch_and_checkout(new_branch_name)
    embed_code_blocks(RENDER_FOLDER, SOURCE_FOLDER)
    update_docs_structure(options)

    pr_title = "Syncing #{latest_commit_sha} with #{current_version}"
    body = <<~EOS
        ⚠️⚠️⚠️ APPROVE THE HOLD JOB IN THIS PR TO SYNC THE DOCS WITH WITH README ⚠️⚠️⚠️
        ⚠️⚠️⚠️ MERGE THE PULL REQUEST WHEN SYNCING HAS FINISHED AND ALL CHECKS HAVE PASSED ⚠️⚠️⚠️
        Syncing docs to release #{current_version} of the docs. This PR was automatically generated by the RevenueCat bot.
    EOS

    if git_repo_dirty?
        commit_changes_and_push_current_branch("Rendered docs for commit #{latest_commit_sha}")
        create_pr_to_main(pr_title, body, REPO_NAME, new_branch_name, github_pr_token, [])
    else
        UI.message("Repository is clean. Nothing to commit.")
    end
end

desc "Embeds code blocks from all files within the [block:file] and [/block] tags"
lane :embed_code_blocks do |options|
    embed_code_blocks(RENDER_FOLDER, SOURCE_FOLDER)
end

desc "Embeds code blocks from all files within the [block:file] and [/block] tags"
lane :preview_rendered_docs do |options|
    preview_rendered_docs(RENDER_FOLDER, TEMPORARY_RENDER_FOLDER, SOURCE_FOLDER)
end

desc "Embeds code blocks from all files within the [block:file] and [/block] tags"
lane :post_circleci_artifacts do |options|
    circleci_build_num = ENV['CIRCLE_BUILD_NUM']
    circleci_token = ENV['CIRCLE_TOKEN']
    github_token = ENV['GITHUB_API_TOKEN']

    post_circleci_artifacts(circleci_build_num, circleci_token, github_token)
end

desc <<-DESC
Updates rendered docs folder to the current category, order and parent information from Readme
readme_api_key, STRING Readme API key for the project
DESC
lane :update_docs_structure do |options|
    readme_api_key = ENV["RDME_API_KEY"]
    UI.user_error!("Missing README API key") unless readme_api_key

    folder_path = RENDER_FOLDER

    update_categories_file(CATEGORIES_FILE, readme_api_key)

    markdown_files(folder_path).each do |file|
        UI.message("Updating #{file}")

        yaml_data = get_doc_information_from_header(file)
        slug = yaml_data["slug"]
        doc_information_from_server = get_doc_information(slug, readme_api_key)

        UI.message("Doc information retrieved from server")
        doc_order = doc_information_from_server["order"]
        doc_parent_doc = doc_information_from_server["parentDoc"]
        doc_category = doc_information_from_server["category"]

        update_doc_information(file, doc_category, doc_order, doc_parent_doc)
    end
end

desc <<-DESC
Removes all categories from docs_source
DESC
lane :clean_docs_source_headers do |options|
    folder_path = SOURCE_FOLDER

    markdown_files(SOURCE_FOLDER).each do |filename|
        next if filename == '.' || filename == '..'
        file_without_folder_path = filename.gsub("#{folder_path}/", "")
        UI.message("Updating #{file_without_folder_path}")

        Dir.chdir(root_dir) do
            file = File.read(filename)
            yaml_header, content = file.split('---', 3)[1..-1]
            yaml_data = YAML.load(yaml_header)

            yaml_data.delete('category')
            yaml_data.delete('metadata')
            yaml_data.delete('createdAt')
            yaml_data.delete('updatedAt')

            File.write(filename, "#{yaml_data.to_yaml}---#{content}")
        end
    end
end

desc <<-DESC
Clean old format images
DESC
lane :clean_images do |options|
    clean_images(SOURCE_FOLDER)
end

desc <<-DESC
Updates the JSON files containing the categories for a Readme.com project.
readme_api_key, STRING Readme API key for the project
readme_api_key_test STRING Readme API key for the test project
DESC
lane :update_categories_file do |options|
    readme_api_key = options[:readme_api_key]
    UI.user_error!("Missing README API key") unless readme_api_key

    update_categories_file(CATEGORIES_FILE, readme_api_key)
end

lane :check_docs_categories do |options|
    check_docs_have_categories(RENDER_FOLDER)
end

lane :migration do |options|
    markdown_files = markdown_files(SOURCE_FOLDER)
    extract_code_blocks(SOURCE_FOLDER, CODE_BLOCKS_FOLDER, markdown_files)
    clean_docs_source_headers
end

# Updates the category, order and parent for a given document.
# It will also update the updatedAt field if needed.
#
# @param [String] filename Name of the file to update
# @param [String] category_id ID of the category to update the document with
# @param [String] order Order of the doc in the category
# @param [String] parent_doc_id Parent ID of the doc
def update_doc_information(filename, category_id, order, parent_doc_id)
    Dir.chdir(root_dir) do
        file = File.read(filename)
        yaml_header, content = file.split('---', 3)[1..-1]
        yaml_data = YAML.load(yaml_header)

        original_category = yaml_data['categorySlug']
        category_slug = find_category_slug_from_id(category_id)
        yaml_data.delete('category') # we don't want any category id, only the slug
        if category_slug && original_category != category_slug
            UI.message("Updating category of #{filename} from #{original_category} to #{category_slug}")
            yaml_data['categorySlug'] = category_slug
        end

        original_order = yaml_data['order']
        if original_order != order
            UI.message("Updating order of #{filename} from #{original_order} to #{order}")
            yaml_data['order'] = order
        end

        original_parent = yaml_data['parentDoc']
        if parent_doc_id && original_parent != parent_doc_id
            UI.message("Updating parent of #{filename} from #{original_parent} to #{parent_doc_id}")
            yaml_data['parentDoc'] = parent_doc_id
        end

        File.write(filename, "#{yaml_data.to_yaml}---#{content}")
    end
end

def get_doc_information_from_header(filename)
    Dir.chdir(root_dir) do
        file = File.read(filename)
        yaml_header, _ = file.split('---', 3)[1..-1]
        YAML.load(yaml_header)
    end
end

def get_current_version
    Dir.chdir(root_dir) do
        File.read(VERSION_FILE).strip
    end
end

# Retrieve a list of categories from the ReadMe API and save it to a file.
#
# @param [String] categories_file Path to the file where the categories will be saved.
# @param [String] readme_api_key API key for the ReadMe account that has access to the categories.
#
# @return [JSON] Categories retrieved from the ReadMe API.
def update_categories_file(categories_file, readme_api_key)
    url = URI("https://dash.readme.com/api/v1/categories?perPage=100&page=1")

    https = Net::HTTP.new(url.host, url.port)
    https.use_ssl = true

    request = Net::HTTP::Get.new(url)
    request.basic_auth(readme_api_key, '')

    request["x-readme-version"] = get_current_version

    response = https.request(request)

    if response.code != '200'
        UI.user_error!("Error retrieving categories from ReadMe.\nResponse code: #{response.code} \nResponse body: #{response.body}")
    end

    json_data = JSON.parse(response.read_body).sort_by { |category| category['order'] }
    Dir.chdir(root_dir) do
        File.open(categories_file, 'w+') do |file|
            file.write(JSON.pretty_generate(json_data))
        end
    end
    json_data
end

# Retrieve the doc information for a given document slug from the ReadMe API.
#
# @param [String] slug The slug of the document to retrieve the category ID for.
# @param [String] readme_api_key API key for the ReadMe account that has access to the document.
#
# @return [Hash] Ruby data structure with the doc's information.
def get_doc_information(slug, readme_api_key)
    url = URI("https://dash.readme.com/api/v1/docs/#{slug}")

    https = Net::HTTP.new(url.host, url.port)
    https.use_ssl = true

    request = Net::HTTP::Get.new(url)
    request.basic_auth(readme_api_key, '')

    request["x-readme-version"] = get_current_version

    response = https.request(request)
    JSON.parse(response.read_body)
end

def git_repo_dirty?
    status = sh("git status --porcelain")
    !status.empty?
end

# Replace with fastlane plugin's
def validate_local_config_status_for_bump(new_branch, github_pr_token)
    # Ensure GitHub API token is set
    if github_pr_token.nil? || github_pr_token.empty?
        UI.error("A github_pr_token parameter or an environment variable GITHUB_API_TOKEN is required to create a pull request")
        UI.error("Please make a fastlane/.env file from the fastlane/.env.SAMPLE template")
        UI.user_error!("Could not find value for GITHUB_PULL_REQUEST_API_TOKEN")
    end
    ensure_new_branch_local_remote(new_branch)
    ensure_git_status_clean
end

# Replace with fastlane plugin's
def self.ensure_new_branch_local_remote(new_branch)
    local_branches = sh('git', 'branch', '--list', new_branch)
    unless local_branches.empty?
        UI.error("Branch '#{new_branch}' already exists in local repository.")
        UI.user_error!("Please make sure it doesn't have any unsaved changes and delete it to continue.")
    end

    remote_branches = sh('git', 'ls-remote', '--heads', 'origin', new_branch)
    if !remote_branches.nil? && remote_branches.include?(new_branch)
        UI.error("Branch '#{new_branch}' already exists in remote repository.")
        UI.user_error!("Please make sure it doesn't have any unsaved changes and delete it to continue.")
    end
end

def get_latest_commit_sha
    sh("git rev-parse --short HEAD").strip
end

# Replace with fastlane plugin's
def create_new_branch_and_checkout(branch_name)
    sh("git checkout -b '#{branch_name}'")
end

# Replace with fastlane plugin's
def commit_changes_and_push_current_branch(commit_message)
    commit_current_changes(commit_message)
    Actions::PushToGitRemoteAction.run(remote: 'origin')
end

def commit_current_changes(commit_message)
    sh('git add -A')
    sh("git commit -am '#{commit_message}'")
end

def create_pr_to_main(title, body, repo_name, head_branch, github_pr_token, labels = [])
    Actions::CreatePullRequestAction.run(
        api_token: github_pr_token,
        title: title,
        base: 'main',
        body: body,
        repo: "RevenueCat/#{repo_name}",
        head: head_branch,
        api_url: 'https://api.github.com',
        labels: labels,
        team_reviewers: ['support']
    )
end
