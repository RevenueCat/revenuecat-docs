# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane
require 'json'
require 'fileutils'

default_platform(:ios)

desc "Install dependencies"
lane :bootstrap do
    sh "npm", "install", "-g", "rdme"
end

desc "Description of what the lane does"
lane :render_docs do |options|
    readme_api_key = options[:readme_api_key]
    UI.user_error!("Missing README API key") unless readme_api_key

    copy_docs_source_to_render_folder
    files_to_render.each do |file|
        render_markdown_file(file)
    end
    sync_files_to_readme readme_api_key: readme_api_key
end

def files_to_render
    root_dir = File.dirname(Dir.pwd)
    Dir.chdir(root_dir) do
        Dir.glob("docs_source/*.md")
    end
end

lane :ios_tests do
    root_dir = File.dirname(Dir.pwd)
    Dir.chdir(File.join(root_dir, "projects", "iOS")) do
        sh "xcodebuild -scheme ApplePlatforms-Package -destination 'generic/platform=iOS'"
    end
end

lane :copy_docs_source_to_render_folder do
    source_folder = "docs_source"
    render_folder = "rendered_docs"
    root_dir = File.dirname(Dir.pwd)
    Dir.chdir(root_dir) do
        FileUtils.copy_entry source_folder, render_folder
    end
end

lane :sync_files_to_readme do |options|
    Dir.chdir("../") do
        sh "rdme docs rendered_docs --version\=4.0 --key\=#{options[:readme_api_key]}"
    end
end

desc <<-DESC
Extracts code blocks from within the [block:code] and [/block] tags and saves each code block to a file
folder, STRING Folder to recurse through and extract code blocks from all markdown files. Path is relative to the root of the project.
DESC
lane :extract_code_blocks do |options|
    folder_to_process = options[:folder]
    UI.user_error!("Missing folder option") unless folder_to_process

    root_dir = File.dirname(Dir.pwd)

    Dir.chdir(root_dir) do
        Dir.glob("#{folder_to_process}/**/*.md") do |file_name|
            current_folder = File.dirname(file_name)
            output_dir = "code_blocks/#{current_folder}"

            file_contents = File.read(file_name)

            FileUtils.mkdir_p(output_dir)

            file_contents.scan(/\[block:code\].*?\[\/block\]/m).each_with_index.map do |block, index|
                UI.message("🔨 Processing code block #{index} in #{file_name}...")

                filename_without_ext = File.basename(file_name, ".md")
                converted_block = extract_block_to_file(output_dir, filename_without_ext, block, index)
                language_to_extracted_file_map = converted_block.map do |lang, file_path|
                    "#{lang}->#{file_path}"
                end.join("\n")

                file_contents.gsub!("#{block}", "[block:file]\n#{language_to_extracted_file_map}\n[/block]")
            end

            File.write(file_name, file_contents)
        end
    end
end


desc <<-DESC
Embeds code blocks from all files within the [block:file] and [/block] tags
folder, STRING Folder to recurse through and embed code blocks from. Path is relative to the root of the project.
DESC
lane :embed_code_blocks do |options|
    folder_to_process = options[:folder]

    root_dir = File.dirname(Dir.pwd)

    Dir.chdir(root_dir) do
        Dir.glob("#{folder_to_process}/**/*.md") do |file_name|
            file_contents = File.read(file_name)

            file_contents.scan(/\[block:file\].*?\[\/block\]/m).each_with_index.map do |block, index|
                UI.message("🔨 Processing file block #{index} in #{file_name}...")
                code_to_embed = embed_code_from_files(block)
                file_contents.gsub!("#{block}", "#{code_to_embed.chomp}")
            end

            File.write(file_name, file_contents)
        end
    end
end

##
# Embeds all files within the [block:file] and [/block] tags and adds the content of the file as a code block
#
# For example this block in a markdown file named docs_source/v4.0.1/-- Resources/server-notifications/example.md:
#
# [block:file]
# javascript->code_blocks/docs_source/v4.0.1/-- Resources/server-notifications/example_1.js
# [/block]
#
# Will be converted to:
# [block:code]
# {
#   "codes": [
#     {
#       "code": "var a = 1;",
#       "language": "javascript"
#     }
#   ]
# }
# [/block]
#
# @param code_block [String] the input string containing the code block. This is the entire string that contains the
# file block including the [block:file] and [/block] tags
# @return [String] a string containing the code blocks from all the files within the file block
def embed_code_from_files(code_block)
    block = extract_code_block(code_block)

    new_content = []

    block.each_line do |line|
        next if line.start_with?("[")
        file_tag_content = line.strip
        file_type, file_path = file_tag_content.split('->')
        next unless File.exist?(file_path)

        file_content = File.read(file_path)
        new_content.push "```#{file_type}\n#{file_content}\n```"
    end

    new_content.join("\n").strip
end

##
# Extracts all code blocks from within the [block:code] and [/block] tags and saves each code block to a file, with the
# correct extension.
#
# For example this code block in a markdown file named docs_source/v4.0.1/-- Resources/server-notifications/example.md:
#
# [block:code]
# {
#   "codes": [
#     {
#       "code": "var a = 1;",
#       "language": "javascript"
#     }
#   ]
# }
# [/block]
#
# Will be converted to:
# [block:file]
# javascript->code_blocks/docs_source/v4.0.1/-- Resources/server-notifications/example_1.js
# [/block]
#
# And the code block will be saved to code_blocks/docs_source/v4.0.1/-- Resources/server-notifications/example_1.js
# @param output_dir [String] the output directory to save the file
# @param file_name_no_ext [String] the name of the file where this code block lives, without extension
# @param code_block [String] the input string containing the code block. This is the entire string that contains the
# code block including the [block:code] and [/block] tags
# @param index [Integer] the index of the code block within the file. This is used to create a unique file name for each
# code block
# @return [Hash] a hash of language to file paths for the extracted code blocks
def extract_block_to_file(output_dir, file_name_no_ext, code_block, index)
    block = extract_code_block(code_block)

    json = block[block.index("{")..block.rindex("}")]
    data = JSON.parse(json)
    codes = data["codes"]

    result = {}

    codes.each do |code|
        language = code["language"]
        code = code["code"].strip
        extension = determine_extension(language)
        new_file = "#{output_dir}/#{file_name_no_ext}_#{index + 1}.#{extension}"
        File.write(new_file, code)
        UI.message("⚙️  Creating #{new_file}...")
        result[language] = new_file
    end

    result
end

def extract_code_block(code_block)
    block_start = code_block.index("[block:")
    block_end = code_block.index("[/block]", block_start)
    code_block[block_start..block_end].strip
end

##
# A map of languages to their corresponding file extensions
LANGUAGE_EXTENSIONS = {
    "objectivec" => "m",
    "kotlin" => "kt",
    "javascript" => "js",
    "typescript" => "ts",
    "csharp" => "cs",
    "text" => "txt"
}

##
# Determines the file extension for a given language
# @param lang [String] the language
# @return [String] the file extension
def determine_extension(lang)
    LANGUAGE_EXTENSIONS[lang] || lang
end

##
# Determines the language for a given file extension
# @param extension [String] the file extension
# @return [String] the language
def determine_language(extension)
    LANGUAGE_EXTENSIONS.key(extension) || extension
end
